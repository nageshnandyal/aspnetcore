// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Microsoft.AspNetCore.OpenApi.SourceGenerators;

public sealed partial class XmlCommentGenerator : IIncrementalGenerator
{
    public static string GeneratedCodeConstructor => $@"System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(XmlCommentGenerator).Assembly.FullName}"", ""{typeof(XmlCommentGenerator).Assembly.GetName().Version}"")";
    public static string GeneratedCodeAttribute => $"[{GeneratedCodeConstructor}]";

    public static string GenerateCacheSource(IEnumerable<(string, string?, XmlComment?)> cacheEntries, IEnumerable<InterceptableLocation?> interceptableLocations) => $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace System.Runtime.CompilerServices
{
    {{GeneratedCodeAttribute}}
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.OpenApi.Generated
{
    using System.Reflection;
    using Microsoft.AspNetCore.OpenApi;

    file record struct XmlComment(string Summary);

    file class XmlCommentService : IXmlCommentService
    {
        internal static readonly Dictionary<(Type, string?), XmlComment> Cache = new()
        {
            {{GenerateCacheEntries(cacheEntries)}}
        };

        public bool TryGetXmlComment((Type, string?) key, out string? summary)
        {
            if (Cache.TryGetValue(key, out var comment))
            {
                summary = comment.Summary;
                return true;
            }
            summary = null;
            return false;
        }

    }
    file static class GeneratedXmlServiceCollectionExtensions
    {
        {{string.Join("\n", interceptableLocations.Select(location => location?.GetInterceptsLocationAttributeSyntax()))}}
        public static IServiceCollection AddXmlServices(this IServiceCollection services)
        {
            return services.AddSingleton<IXmlCommentService, XmlCommentService>();
        }
    }
}
""";

    internal static string GenerateCacheEntries(IEnumerable<(string, string?, XmlComment?)> cacheEntries)
    {
        var entries = new List<string>();
        foreach (var (type, member, comment) in cacheEntries)
        {
            if (comment is not null)
            {
                if (member is not null)
                {
                    entries.Add($"{{ (typeof({type}), nameof({member})), new XmlComment(\"{comment.Summary}\") }}");
                }
                else
                {
                    entries.Add($"{{ (typeof({type}), null), new XmlComment(\"{comment.Summary}\") }}");
                }
            }
        }
        return string.Join(",\n", entries);
    }

    internal static void EmitXmlCommentCache(SourceProductionContext context, IEnumerable<(string, string?, XmlComment?)> comments, IEnumerable<InterceptableLocation?> interceptableLocations)
    {
        context.AddSource("XmlCommentGenerator.CommentCache.generated.cs", GenerateCacheSource(comments, interceptableLocations));
    }
}
